/**
 * marked - a markdown parser
 * Copyright (c) 2011-2013, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/chjj/marked
 */
(function () {
    function r(a) {
        this.tokens = [];
        this.tokens.links = {};
        this.options = a || k.defaults;
        this.rules = f.normal;
        this.options.gfm && (this.rules = this.options.tables ? f.tables : f.gfm)
    }

    function p(a, d) {
        this.options = d || k.defaults;
        this.links = a;
        this.rules = j.normal;
        if (!this.links)throw Error("Tokens array requires a `links` property.");
        this.options.gfm ? this.rules = this.options.breaks ? j.breaks : j.gfm : this.options.pedantic && (this.rules = j.pedantic)
    }

    function n(a) {
        this.tokens = [];
        this.token = null;
        this.options = a || k.defaults
    }

    function l(a, d) {
        return a.replace(!d ? /&(?!#?\w+;)/g : /&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;")
    }

    function m(a, d) {
        a = a.source;
        d = d || "";
        return function b(c, f) {
            if (!c)return RegExp(a, d);
            f = f.source || f;
            f = f.replace(/(^|[^\[])\^/g, "$1");
            a = a.replace(c, f);
            return b
        }
    }

    function s() {
    }

    function q(a) {
        for (var d = 1, e, b; d < arguments.length; d++)for (b in e = arguments[d], e)Object.prototype.hasOwnProperty.call(e, b) && (a[b] = e[b]);
        return a
    }

    function k(a, d) {
        try {
            return d && (d = q({},
                k.defaults, d)), n.parse(r.lex(a, d), d)
        } catch (e) {
            e.message += "\nPlease report this to https://github.com/chjj/marked.";
            if ((d || k.defaults).silent)return"<p>An error occured:</p><pre>" + l(e.message + "", !0) + "</pre>";
            throw e;
        }
    }

    var f = {newline: /^\n+/, code: /^( {4}[^\n]+\n*)+/, fences: s, hr: /^( *[-*_]){3,} *(?:\n+|$)/, heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/, nptable: s, lheading: /^([^\n]+)\n *(=|-){3,} *\n*/, blockquote: /^( *>[^\n]+(\n[^\n]+)*\n*)+/, list: /^( *)(bull) [\s\S]+?(?:hr|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
        html: /^ *(?:comment|closed|closing) *(?:\n{2,}|\s*$)/, def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/, table: s, paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/, text: /^[^\n]+/, bullet: /(?:[*+-]|\d+\.)/, item: /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/};
    f.item = m(f.item, "gm")(/bull/g, f.bullet)();
    f.list = m(f.list)(/bull/g, f.bullet)("hr", /\n+(?=(?: *[-*_]){3,} *(?:\n+|$))/)();
    f._tag = "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|@)\\b";
    f.html = m(f.html)("comment", /\x3c!--[\s\S]*?--\x3e/)("closed", /<(tag)[\s\S]+?<\/\1>/)("closing", /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)(/tag/g, f._tag)();
    f.paragraph = m(f.paragraph)("hr", f.hr)("heading", f.heading)("lheading", f.lheading)("blockquote", f.blockquote)("tag", "<" + f._tag)("def", f.def)();
    f.normal = q({}, f);
    f.gfm = q({}, f.normal, {fences: /^ *(`{3,}|~{3,}) *(\w+)? *\n([\s\S]+?)\s*\1 *(?:\n+|$)/, paragraph: /^/});
    f.gfm.paragraph = m(f.paragraph)("(?!", "(?!" + f.gfm.fences.source.replace("\\1", "\\2") + "|")();
    f.tables =
        q({}, f.gfm, {nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/, table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/});
    r.rules = f;
    r.lex = function (a, d) {
        return(new r(d)).lex(a)
    };
    r.prototype.lex = function (a) {
        a = a.replace(/\r\n|\r/g, "\n").replace(/\t/g, "    ").replace(/\u00a0/g, " ").replace(/\u2424/g, "\n");
        return this.token(a, !0)
    };
    r.prototype.token = function (a, d) {
        a = a.replace(/^ +$/gm, "");
        for (var e, b, c, j, g, h, k; a;) {
            if (c = this.rules.newline.exec(a))a = a.substring(c[0].length), 1 <
                c[0].length && this.tokens.push({type: "space"});
            if (c = this.rules.code.exec(a))a = a.substring(c[0].length), c = c[0].replace(/^ {4}/gm, ""), this.tokens.push({type: "code", text: !this.options.pedantic ? c.replace(/\n+$/, "") : c}); else if (c = this.rules.fences.exec(a))a = a.substring(c[0].length), this.tokens.push({type: "code", lang: c[2], text: c[3]}); else if (c = this.rules.heading.exec(a))a = a.substring(c[0].length), this.tokens.push({type: "heading", depth: c[1].length, text: c[2]}); else if (d && (c = this.rules.nptable.exec(a))) {
                a =
                    a.substring(c[0].length);
                g = {type: "table", header: c[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: c[2].replace(/^ *|\| *$/g, "").split(/ *\| */), cells: c[3].replace(/\n$/, "").split("\n")};
                for (h = 0; h < g.align.length; h++)g.align[h] = /^ *-+: *$/.test(g.align[h]) ? "right" : /^ *:-+: *$/.test(g.align[h]) ? "center" : /^ *:-+ *$/.test(g.align[h]) ? "left" : null;
                for (h = 0; h < g.cells.length; h++)g.cells[h] = g.cells[h].split(/ *\| */);
                this.tokens.push(g)
            } else if (c = this.rules.lheading.exec(a))a = a.substring(c[0].length), this.tokens.push({type: "heading",
                depth: "=" === c[2] ? 1 : 2, text: c[1]}); else if (c = this.rules.hr.exec(a))a = a.substring(c[0].length), this.tokens.push({type: "hr"}); else if (c = this.rules.blockquote.exec(a))a = a.substring(c[0].length), this.tokens.push({type: "blockquote_start"}), c = c[0].replace(/^ *> ?/gm, ""), this.token(c, d), this.tokens.push({type: "blockquote_end"}); else if (c = this.rules.list.exec(a)) {
                a = a.substring(c[0].length);
                j = c[2];
                this.tokens.push({type: "list_start", ordered: 1 < j.length});
                c = c[0].match(this.rules.item);
                e = !1;
                k = c.length;
                for (h = 0; h <
                    k; h++)g = c[h], b = g.length, g = g.replace(/^ *([*+-]|\d+\.) +/, ""), ~g.indexOf("\n ") && (b -= g.length, g = !this.options.pedantic ? g.replace(RegExp("^ {1," + b + "}", "gm"), "") : g.replace(/^ {1,4}/gm, "")), this.options.smartLists && h !== k - 1 && (b = f.bullet.exec(c[h + 1])[0], j !== b && !(1 < j.length && 1 < b.length) && (a = c.slice(h + 1).join("\n") + a, h = k - 1)), b = e || /\n\n(?!\s*$)/.test(g), h !== k - 1 && (e = "\n" === g[g.length - 1], b || (b = e)), this.tokens.push({type: b ? "loose_item_start" : "list_item_start"}), this.token(g, !1), this.tokens.push({type: "list_item_end"});
                this.tokens.push({type: "list_end"})
            } else if (c = this.rules.html.exec(a))a = a.substring(c[0].length), this.tokens.push({type: this.options.sanitize ? "paragraph" : "html", pre: "pre" === c[1], text: c[0]}); else if (d && (c = this.rules.def.exec(a)))a = a.substring(c[0].length), this.tokens.links[c[1].toLowerCase()] = {href: c[2], title: c[3]}; else if (d && (c = this.rules.table.exec(a))) {
                a = a.substring(c[0].length);
                g = {type: "table", header: c[1].replace(/^ *| *\| *$/g, "").split(/ *\| */), align: c[2].replace(/^ *|\| *$/g, "").split(/ *\| */),
                    cells: c[3].replace(/(?: *\| *)?\n$/, "").split("\n")};
                for (h = 0; h < g.align.length; h++)g.align[h] = /^ *-+: *$/.test(g.align[h]) ? "right" : /^ *:-+: *$/.test(g.align[h]) ? "center" : /^ *:-+ *$/.test(g.align[h]) ? "left" : null;
                for (h = 0; h < g.cells.length; h++)g.cells[h] = g.cells[h].replace(/^ *\| *| *\| *$/g, "").split(/ *\| */);
                this.tokens.push(g)
            } else if (d && (c = this.rules.paragraph.exec(a)))a = a.substring(c[0].length), this.tokens.push({type: "paragraph", text: "\n" === c[1][c[1].length - 1] ? c[1].slice(0, -1) : c[1]}); else if (c = this.rules.text.exec(a))a =
                a.substring(c[0].length), this.tokens.push({type: "text", text: c[0]}); else if (a)throw Error("Infinite loop on byte: " + a.charCodeAt(0));
        }
        return this.tokens
    };
    var j = {escape: /^\\([\\`*{}\[\]()#+\-.!_>])/, autolink: /^<([^ >]+(@|:\/)[^ >]+)>/, url: s, tag: /^\x3c!--[\s\S]*?--\x3e|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/, link: /^!?\[(inside)\]\(href\)/, reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/, nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/, strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/, em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
        code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/, br: /^ {2,}\n(?!\s*$)/, del: s, text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/, _inside: /(?:\[[^\]]*\]|[^\]]|\](?=[^\[]*\]))*/, _href: /\s*<?([^\s]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/};
    j.link = m(j.link)("inside", j._inside)("href", j._href)();
    j.reflink = m(j.reflink)("inside", j._inside)();
    j.normal = q({}, j);
    j.pedantic = q({}, j.normal, {strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/, em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/});
    j.gfm = q({},
        j.normal, {escape: m(j.escape)("])", "~|])")(), url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/, del: /^~~(?=\S)([\s\S]*?\S)~~/, text: m(j.text)("]|", "~]|")("|", "|https?://|")()});
    j.breaks = q({}, j.gfm, {br: m(j.br)("{2,}", "*")(), text: m(j.gfm.text)("{2,}", "*")()});
    p.rules = j;
    p.output = function (a, d, e) {
        return(new p(d, e)).output(a)
    };
    p.prototype.output = function (a) {
        for (var d = "", e, b; a;)if (b = this.rules.escape.exec(a))a = a.substring(b[0].length), d += b[1]; else if (b = this.rules.autolink.exec(a))a = a.substring(b[0].length), "@" ===
            b[2] ? (e = ":" === b[1][6] ? this.mangle(b[1].substring(7)) : this.mangle(b[1]), b = this.mangle("mailto:") + e) : b = e = l(b[1]), d += '<a href="' + b + '">' + e + "</a>"; else if (b = this.rules.url.exec(a))a = a.substring(b[0].length), b = e = l(b[1]), d += '<a href="' + b + '">' + e + "</a>"; else if (b = this.rules.tag.exec(a))a = a.substring(b[0].length), d += this.options.sanitize ? l(b[0]) : b[0]; else if (b = this.rules.link.exec(a))a = a.substring(b[0].length), d += this.outputLink(b, {href: b[2], title: b[3]}); else if ((b = this.rules.reflink.exec(a)) || (b = this.rules.nolink.exec(a)))a =
            a.substring(b[0].length), e = (b[2] || b[1]).replace(/\s+/g, " "), e = this.links[e.toLowerCase()], !e || !e.href ? (d += b[0][0], a = b[0].substring(1) + a) : d += this.outputLink(b, e); else if (b = this.rules.strong.exec(a))a = a.substring(b[0].length), d += "<strong>" + this.output(b[2] || b[1]) + "</strong>"; else if (b = this.rules.em.exec(a))a = a.substring(b[0].length), d += "<em>" + this.output(b[2] || b[1]) + "</em>"; else if (b = this.rules.code.exec(a))a = a.substring(b[0].length), d += "<code>" + l(b[2], !0) + "</code>"; else if (b = this.rules.br.exec(a))a =
            a.substring(b[0].length), d += "<br>"; else if (b = this.rules.del.exec(a))a = a.substring(b[0].length), d += "<del>" + this.output(b[1]) + "</del>"; else if (b = this.rules.text.exec(a))a = a.substring(b[0].length), d += l(b[0]); else if (a)throw Error("Infinite loop on byte: " + a.charCodeAt(0));
        return d
    };
    p.prototype.outputLink = function (a, d) {
        return"!" !== a[0][0] ? '<a href="' + l(d.href) + '"' + (d.title ? ' title="' + l(d.title) + '"' : "") + ">" + this.output(a[1]) + "</a>" : '<img src="' + l(d.href) + '" alt="' + l(a[1]) + '"' + (d.title ? ' title="' + l(d.title) +
            '"' : "") + ">"
    };
    p.prototype.mangle = function (a) {
        for (var d = "", e = a.length, b = 0, c; b < e; b++)c = a.charCodeAt(b), 0.5 < Math.random() && (c = "x" + c.toString(16)), d += "&#" + c + ";";
        return d
    };
    n.parse = function (a, d) {
        return(new n(d)).parse(a)
    };
    n.prototype.parse = function (a) {
        this.inline = new p(a.links, this.options);
        this.tokens = a.reverse();
        for (a = ""; this.next();)a += this.tok();
        return a
    };
    n.prototype.next = function () {
        return this.token = this.tokens.pop()
    };
    n.prototype.peek = function () {
        return this.tokens[this.tokens.length - 1] || 0
    };
    n.prototype.parseText =
        function () {
            for (var a = this.token.text; "text" === this.peek().type;)a += "\n" + this.next().text;
            return this.inline.output(a)
        };
    n.prototype.tok = function () {
        switch (this.token.type) {
            case "space":
                return"";
            case "hr":
                return"<hr>\n";
            case "heading":
                return"<h" + this.token.depth + ">" + this.inline.output(this.token.text) + "</h" + this.token.depth + ">\n";
            case "code":
                if (this.options.highlight) {
                    var a = this.options.highlight(this.token.text, this.token.lang);
                    null != a && a !== this.token.text && (this.token.escaped = !0, this.token.text = a)
                }
                this.token.escaped ||
                (this.token.text = l(this.token.text, !0));
                return"<pre><code" + (this.token.lang ? ' class="' + this.options.langPrefix + this.token.lang + '"' : "") + ">" + this.token.text + "</code></pre>\n";
            case "table":
                var d, e, b, c, a = "<thead>\n<tr>\n";
                for (e = 0; e < this.token.header.length; e++)d = this.inline.output(this.token.header[e]), a += this.token.align[e] ? '<th align="' + this.token.align[e] + '">' + d + "</th>\n" : "<th>" + d + "</th>\n";
                a += "</tr>\n</thead>\n<tbody>\n";
                for (e = 0; e < this.token.cells.length; e++) {
                    d = this.token.cells[e];
                    a += "<tr>\n";
                    for (c =
                             0; c < d.length; c++)b = this.inline.output(d[c]), a += this.token.align[c] ? '<td align="' + this.token.align[c] + '">' + b + "</td>\n" : "<td>" + b + "</td>\n";
                    a += "</tr>\n"
                }
                a += "</tbody>\n";
                return"<table>\n" + a + "</table>\n";
            case "blockquote_start":
                for (a = ""; "blockquote_end" !== this.next().type;)a += this.tok();
                return"<blockquote>\n" + a + "</blockquote>\n";
            case "list_start":
                e = this.token.ordered ? "ol" : "ul";
                for (a = ""; "list_end" !== this.next().type;)a += this.tok();
                return"<" + e + ">\n" + a + "</" + e + ">\n";
            case "list_item_start":
                for (a = ""; "list_item_end" !==
                    this.next().type;)a += "text" === this.token.type ? this.parseText() : this.tok();
                return"<li>" + a + "</li>\n";
            case "loose_item_start":
                for (a = ""; "list_item_end" !== this.next().type;)a += this.tok();
                return"<li>" + a + "</li>\n";
            case "html":
                return!this.token.pre && !this.options.pedantic ? this.inline.output(this.token.text) : this.token.text;
            case "paragraph":
                return"<p>" + this.inline.output(this.token.text) + "</p>\n";
            case "text":
                return"<p>" + this.parseText() + "</p>\n"
        }
    };
    s.exec = s;
    k.options = k.setOptions = function (a) {
        q(k.defaults, a);
        return k
    };
    k.defaults = {gfm: !0, tables: !0, breaks: !1, pedantic: !1, sanitize: !1, smartLists: !1, silent: !1, highlight: null, langPrefix: "lang-"};
    k.Parser = n;
    k.parser = n.parse;
    k.Lexer = r;
    k.lexer = r.lex;
    k.InlineLexer = p;
    k.inlineLexer = p.output;
    k.parse = k;
    "object" === typeof exports ? module.exports = k : "function" === typeof define && define.amd ? define(function () {
        return k
    }) : this.marked = k
}).call(function () {
        return this || ("undefined" !== typeof window ? window : global)
    }());
