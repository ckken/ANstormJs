{
  "name": "thenjs",
  "description": "Another very small asynchronous promise tool!",
  "author": {
    "name": "zensh"
  },
  "version": "0.9.2",
  "main": "then.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/teambition/then.js"
  },
  "homepage": "https://github.com/teambition/then.js",
  "keywords": [
    "promise",
    "then"
  ],
  "tags": [
    "promise",
    "then"
  ],
  "readme": "then.js 0.9.2\r\n====\r\nAnother very small asynchronous promise tool! (less than 300 lines, 3.x KB min.js, 1.x KB gzipped)\r\n\r\n**能用简单优美的方式将任何同步或异步回调函数转换成then()链式调用！**\r\n\r\n## 特征\r\n\r\n1. 无需像Q.js那样封装，可以用自然的方式直接把N多异步回调函数写成一个长长的then链；\r\n2. 拥有类似Async.js但更强大的each、eachSeries、parallel、series批量异步组合函数，它们都可在then链上调用；\r\n3. Error收集器fail方法可在任意位置调用，可以调用一次或多次，让你随心所欲处理各种Error。还可以把fail放在末尾当作殿后函数运行（即不管then链成功或失败均运行该函数）；\r\n4. 开启debug模式，可以把每一个then链运行结果输出到debug函数（未定义debug函数则console.log打印）\r\n\r\n## Install\r\n\r\n**Node.js:**\r\n\r\n    npm install thenjs\r\n\r\n**bower:**\r\n\r\n    bower install thenjs\r\n\r\n**Browser:**\r\n\r\n    <script src=\"/pathTo/then.js\"></script>\r\n\r\n**with require**\r\n\r\n    var then = require('thenjs');\r\n\r\n**with define**\r\n\r\n    define(['thenjs'], function (then) {\r\n        //...\r\n    });\r\n\r\n**注意：then.js需要bind方法和Array.isArray方法支持，IE8及以下请先加载es5-shim.js**\r\n\r\n\r\n## API\r\n\r\n### 1. 主函数\r\n\r\n#### then([startHandler], [context], [debug])\r\nstartHandler是可选的，如果未提供，将直接进入下一个then object。\r\n\r\n***Parameters:***\r\n\r\n+ **startHander:** function (defer) {}\r\n+ **context:** 为startHandler绑定的this值，下同\r\n+ **debug:** debug为函数或其它真值时就对本then链开启调试模式，逐步将每一个链的defer运行结果用debug函数处理，如果debug为非函数真值，则调用console.log打印，下同\r\n\r\n***Return:*** then object\r\n\r\n#### then.each(array, iterator, [context], [debug])\r\n将array中的值应用于iterator函数（同步或异步任务），并行执行。iterator的第一个参数defer用于收集err和运行结果，所有结果将形成一个结果数组进入下一个then object，结果数组的顺序与array对应。当所有iterator任务运行完毕，或者defer捕捉到任何一个err，即进入下一个then object。如果array为空数组，结果数组也将为空数组，iterator不会执行而直接进入下一个then object。\r\n\r\n***Parameters:***\r\n\r\n+ **array:** array apply to iterator\r\n+ **taskIterator:** function (defer, value, index, array) {}\r\n+ **context:** context apply to iterator\r\n\r\n***Return:*** then object\r\n\r\n#### then.eachSeries(array, iterator, [context], [debug])\r\n将array中的值应用于iterator函数（同步或异步任务），按顺序执行，上一个任务执行完毕才开始执行下一个任务。iterator的第一个参数defer用于收集err和运行结果，所有结果将形成一个结果数组进入下一个then object，结果数组的顺序与array对应。当所有iterator任务运行完毕，或者defer捕捉到任何一个err，即进入下一个then object。如果array为空数组，结果数组也将为空数组，iterator不会执行而直接进入下一个then object。\r\n\r\n***Parameters:***\r\n\r\n+ **array:** array apply to iterator\r\n+ **taskIterator:** function (defer, value, index, array) {}\r\n+ **context:** context apply to iterator\r\n\r\n***Return:*** then object\r\n\r\n\r\n#### then.parallel(taskArray, [context], [debug])\r\ntaskArray是一系列同步或异步任务函数组成的数组，并行执行。taskArray中每一个函数的第一个参数defer用于收集err和运行结果，所有结果将形成一个结果数组进入下一个then object，结果数组的顺序与taskArray对应。当所有taskArray任务运行完毕，或者defer捕捉了任何一个err，即进入下一个then object。如果taskArray为空数组，结果数组也将为空数组，将会直接进入下一个then object。\r\n\r\n***Parameters:***\r\n\r\n+ **taskArray:** [taskFn1, taskFn2, taskFn3, ...]\r\n+ **taskFn in taskArray:** function (defer) {}\r\n+ **context:** context apply to iterator\r\n\r\n***Return:*** then object\r\n\r\n#### then.series(taskArray, [context], [debug])\r\ntaskArray是一系列同步或异步任务函数组成的数组，按顺序执行，上一个任务执行完毕才开始执行下一个任务。taskArray中每一个函数的有第一个参数defer用于收集err和运行结果，所有结果将形成一个结果数组进入下一个then object，结果数组的顺序与taskArray对应。当所有taskArray任务运行完毕，或者defer捕捉了任何一个err，即进入下一个then object。如果taskArray为空数组，结果数组也将为空数组，将会直接进入下一个then object。\r\n\r\n***Parameters:***\r\n\r\n+ **taskArray:** [taskFn1, taskFn2, taskFn3, ...]\r\n+ **taskFn in taskArray:** function (defer) {}\r\n+ **context:** context apply to iterator\r\n\r\n***Return:*** then object\r\n\r\n\r\n### 2. *then object*的方法\r\n\r\n#### .all(allHandler)\r\n若all存在，则上一个then对象无论是捕捉到err还是正常结果，均进入all执行，allHandler可用上层then对象的defer代替`.all(defer)`。\r\n\r\n***Parameters:***\r\n\r\n+ **allHandler:** function (defer, err, value…) {}\r\n\r\n***Return:*** then object\r\n\r\n#### .then(successHandler, [errorHandler])\r\n若errorHandler存在，上一个then对象捕捉到err则执行errorHandler，否则执行successHandler， errorHandler可用上层then对象的defer代替，successHandler则不能（否则会把第一个value当作err处理）。\r\n\r\n***Parameters:***\r\n\r\n+ **successHandler:** function (defer, value…) {}\r\n+ **errorHandler:** function (defer, err) {}\r\n\r\n***Return:*** then object\r\n\r\n#### .fail(errorHandler)\r\nfail用于捕捉在它之前的then链上发生的任何err。若fail存在，fail之前的then链发生了err，且没有被all的allHandler或then的errorHandler捕捉，则err直接进入最近的fail节点，err发生点与fail之间的then链不会被执行。errorHandler可用上层then对象的defer代替`.fail(defer)`。一个then链可存在0个或多个fail方法，强烈建议then链的最后一个then对象为fail方法。如果then链中没有任何err捕捉器，则err会直接throw。**fail方法可用于运行殿后函数：对一个一条then链，使用`defer(true)`把最后无err运行的then对象导向末端的fail，则该then链不管是正确运行还是发生了err，均会执行末端的fail方法。**\r\n\r\n***Parameters:***\r\n\r\n+ **errorHandler:** function (defer, err) {}\r\n\r\n***Return:*** then object\r\n\r\n#### .each(array, iterator, [context])\r\n参数类似then.each。不同在于，一是无debug参数; 当array, iterator, context为null或undefined时，此处的each会查找上一个then对象的输出结果，如果存在，则作为它的运行参数：例如上一个then对象输出`defer(null, array1, iterator1)`，此处为`each(null, null, this)`，则该each会获取array1, iterator1作为为它的参数运行。\r\n\r\n#### .eachSeries(array, iterator, [context])\r\n参数类似then.eachSeries。不同处类似上面.each。\r\n\r\n#### .parallel(taskArray, [context])\r\n参数类似then.eachSeries。不同处类似上面.each。\r\n\r\n#### .series(taskArray, [context])\r\n参数类似then.eachSeries。不同处类似上面.each。\r\n\r\n### 3. 其他说明\r\n\r\n\r\n1. 关于Error收集器\r\n\r\n    then对象的then方法的errorHandler函数、all方法、fail方法均能收集error。其中then方法的errorHandler函数和all方法只能收集上一个then对象产生的error；fail方法则能收集再它之前所有then链产生的error。\r\n\r\n2. 关于触发器`defer`\r\n\r\n    then.js中最关键的就是`defer`，用于触发下一个then链。从上面可知，入口函数、then方法、all方法、fail方法中的任务函数的第一个参数都被注入了defer方法，**如果任务函数本身是一个defer方法，则不会再被注入defer方法**。\r\n\r\n    defer的第一个参数永远是error，如果error存在，则error下一个then对象的Error收集器，如果Error收集器不存在，则抛出error。\r\n\r\n    如果异步任务的callback的第一个参数为error，即callback(error, result1, ...)的形式，则可直接用defer代替异步任务的callback。Node.js中的异步函数基本都是这种形式，then.js用起来超方便。\r\n\r\n    **如果一个函数体内的同一个defer被多次调用，那么只有最先被触发的那个defer有效**。这个效果类似于`or`：多个异步任务同时进行，最先返回的结果进入下一个then链，其它后返回的结果忽略。\r\n\r\n3. 关于fail方法\r\n\r\n    `fail`方法能捕捉在它之前的then链中的任何一个error。fail的优先级低于then方法的errorHandler和all方法，即then对象不存在then方法的errorHandler和all方法时error才会进入fail。当then链的某个then对象产生了error时，如果该then对象的下一个then对象存在Error收集器，则error进入该Error收集器，否则error会直接进入then链下游最近的fail方法，其间的then对象均会跳过。\r\n\r\n\r\n\r\n## then.js使用模式\r\n\r\n**直链：**\r\n\r\n    then(function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).then(function (defer, value) {\r\n        // ....\r\n        defer(err, ...);\r\n    }, function (defer, err) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).then(function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).all(function (defer, err, value) {\r\n        // ....\r\n        defer(err, array);\r\n    }).each(null, function (defer, value) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).eachSeries(null, function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).parallel(null, function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).series(null, function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).fail(function (defer, err) {\r\n        // ....\r\n    });\r\n\r\n\r\n**嵌套：**\r\n\r\n    then(function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).then(function (defer, value) {\r\n        //第二层\r\n        then(function (defer2) {\r\n            // ....\r\n            defer2(err, ...);\r\n        }).then(function (defer2, value) {\r\n            //第三层\r\n            then(function (defer3) {\r\n                // ....\r\n            }).all(defer2); // 返回二层\r\n        }).then(function (defer2) {\r\n            // ....\r\n            defer(err, ...); // 返回一层\r\n        }).fail(defer); // 返回一层\r\n    }).then(function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).fail(function (defer, err) {\r\n        // ....\r\n    });\r\n\r\n\r\n**async 嵌套：**\r\n\r\n    then(function (defer) {\r\n        // ....\r\n        defer(err, array);\r\n    }).then(function (defer, array) {\r\n        // ....并行执行任务\r\n        then.each(array, function (defer2, value) {\r\n            defer2();\r\n        }, defer);\r\n    }).then(function (defer, array) {\r\n        // ....逐步执行任务\r\n        then.eachSeries(array, function (defer2, value) {\r\n            defer2();\r\n        }, defer);\r\n    }).then(function (defer, array) {\r\n        // ....并行执行任务\r\n        then.parallel([function (defer2) {\r\n            //任务1\r\n            defer2();\r\n        }, function (defer2) {\r\n            //任务2\r\n            defer2();\r\n        }, function (defer2) {\r\n            //任务3\r\n            defer2();\r\n        }, ...], defer);\r\n    }).then(function (defer, array) {\r\n        // ....逐步执行任务\r\n        then.series([function (defer2) {\r\n            //任务1\r\n            defer2();\r\n        }, function (defer2) {\r\n            //任务2\r\n            defer2();\r\n        }, function (defer2) {\r\n            //任务3\r\n            defer2();\r\n        }, ...], defer);\r\n    }).then(function (defer) {\r\n        // ....\r\n        defer(err, ...);\r\n    }).fail(function (defer, err) {\r\n        // ....\r\n    });\r\n\r\n**then对象取代callback：**\r\n\r\n    function getFileAsync() {\r\n        return then(function (defer) {\r\n            readFile(failname, defer);\r\n        }).then(function (defer, fileContent) {\r\n            // 处理fileContent\r\n            defer(null, result);\r\n        }).fail(function (defer, err) {\r\n            // 处理error\r\n            defer(err);\r\n        });\r\n    }\r\n\r\n    getFileAsync().then(function (defer, file) {\r\n        // ....\r\n    }).fail(function(defer, err) {\r\n        // ....\r\n    });\r\n\r\n\r\n\r\n### Who Used\r\n\r\n + AngularJS中文社区：[http://angularjs.cn/]()\r\n + Teambition：[http://teambition.com/]()\r\n\r\n\r\n## Examples\r\n\r\n**参见demo——test.js**\r\n\r\n更多使用案例请参考[jsGen](https://github.com/zensh/jsgen)源代码！\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/teambition/then.js/issues"
  },
  "_id": "thenjs@0.9.2",
  "dist": {
    "shasum": "ae2e586679dd2daa121c8f84e5d60b5bb5aaa912"
  },
  "_from": "thenjs@*",
  "_resolved": "https://registry.npmjs.org/thenjs/-/thenjs-0.9.2.tgz"
}
